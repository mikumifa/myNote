# C++隐秘规则的补充

## C++&和&&的用法

###### &

```
string *p=&s;//取地址
int &p=a;//引用
int* &p=&a;//指针的引用
void swap(int &a,int &b);//形参的改变会改变实参
```

```
void func(int(&a)[5]);//数组引用作为函数的参数，必须指明数组的长度
```

###### 常引用

```
void func2(const string &str);//str不可以改变
//常引用和常指针一样，所指的值无法改变
```

###### 左值和右值

左值：lvalue->loactor value储存在内存中，有明确存储地址的数据

右值：rvalue->reed value不一定可以寻址，例如存储于寄存器中的数据，例如说表达式的值

```
//左值引用
int num = 10;
int &b = num;     // 正确
int &c = 10;      // 错误
// 右值引用
int num = 10;
//int && a = num;    // 错误，右值引用不能初始化为左值
int && a = 10;       // 正确
```

###### 右值引用可以用来move constructer

```
User::User(User&&p){
	this->p=p;//this->p指向了p的p,
	p=nullptr;//为了防止p被重复析构，原来的p设为nullptr.
	对空指针使用nullptr是可以的。
}
```

说白了，就是用右值引用引用一个值，然后把里面的指针给转移到现有的上面。

## 逗号表达式

逗号表达式的值是最后一个的值

## 二维数组

```c++ 
//new 一个
int **p=new int*[10];//先new一个有10个元素的指针数组，*是在类型的后面，变量的前面。
for(int i = 0; i < 10; ++i){
  p[i] = new int[5];
}
//二维数组可以降纬操作，想象空间是一排连一起的
```

## Struct的对齐操作

```c++
1、第一个成员的首地址为0.

2、每个成员的首地址是自身大小的整数倍

3、结构体的总大小，为其成员中所含最大类型的整数倍
//宏声明的和实际数据类型中最大值较小（如果有宏声明）
//内存对齐主要是为了提高访问的效率
#pragma pack(n)//这个是宏定义
```

## 函数

函数编译链接

```
编译的时候只编译当前的模块，只有到链接的时候，a.obj才会从b.obj中获得f()函数的信息(这就是为什么要预先)，
链接的时候主要是为了确定各部分的地址，将编译记过中的地址符号全部换成实地址。
```

函数的默认参数

```
必须从右向左
```

函数重载

```
不允许参数的个数，类型，顺序完全相同
//函数不能既为重载函数，又为有默认参数函数。
当未传入参数时，系统无法判定调用哪一个参数。
```

符号表机制（编译的时候产生）

```c
/*与编译的各个阶段都有交互，存有函数名、地址等信息；编译时会创建一个函数符号表<name,address>，对应的符号后面的地址还没确定(link期决定)，call name根据name找到符号表对应的地址，再执行。
对于c语言来说，编译得到的符号表内函数f在符号表里的name就是f(不存在函数重载)*/
extern void f();//这个是c的函数，使用extern
void g(){
    f();
}
```

函数的内存![](http://pic.mikumifa.cn/2022/11/02/42b8e005e0110.png)

1. 从上往下分别是
   - code:每个指令都有对应的单元地址。函数的代码存放的位置是受到限制的
   - Data:存放数据(局部变量和全局变量)
   - Stack:由系统管理，存放函数
   - Heap:可以用程序员进行分配，可以在运行时动态确定，`int *p = (int *)malloc(4)`，归还内存`free`(在C++中不推荐使用这种方法进行处理，而是使用new和delete)

## RunTime Environment

_cdecl，函数空间(参数)归**调用者**管理，本章讲解的是这种，也就是被调用者不清空栈，调用者清空栈。

问题:函数调用者结束后，原空间的参数仍然在(未归还)

好处:由调用者管理所有的调用参数，可以灵活管理参数。

坏处:安全问题，调用者环境被破坏

_stdcal函数调用后，函数空间由被调用者管理，被调用者清空栈。

调用者来传递参数(申请空间)，由被调用者归还参数(归还空间)，这部分空间被称为**中间地带**。caller:调用者，callee:被调用者

好处:空间节省，跨平台性。

坏处:对于可变参数的函数无法计算ebp的参数个数，但是对于调用者是知道的，这样只能使用_cdecl

## 栈空间

![img](https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/function/1.png)

- 栈空间是从高地址向低地址生长

- 栈底:ebp(当前函数的存取指针，即存储或者读取数时的指针基地址)

- 栈顶:esp(当前函数的栈顶指针)

- 保存:返回地址、调用者的基指针

- 过程描述:调用一个函数时，先将堆栈原先的基址(ebp)入栈，以保存之前任务的信息。然后将栈顶指针的值赋给ebp，**将之前的栈顶作为新的基址**(栈底)，然后**在这个基址上开辟相应的空间用作被调用函数的堆栈**。函数返回后，**从ebp中可取出之前的esp值，使栈顶恢复函数调用前的位置**；再从恢复后的栈顶可弹出之前的EBP值，因为这个值在函数调用前一步被压入堆栈。这样，EBP和ESP就都恢复了调用前的位置，堆栈恢复函数调用前的状态。

- ```
  开始调用esp从栈顶向下移动32位，存ret_addr，开辟main函数的栈空间
  然后esp继续向下存esp_main
  然后ebp到esp处
  然后esp到新的函数空间的栈顶
  函数处理
  esp先返回到ebp
  然后ebp根据esp_main返回，然后esp加一(向上)
  之后esp回到ret_addr位置即可。
  ```

  ## 内联函数

目的:

1. 提高可读性

2. 提高效率

   编译系统将为 inline 函数创建一段代码，在调用点，以相应的代码替换

限制：必须是非递归的函数，由编译系统控制，和编译器相关，inline是请求，不一定是内联函数。

缺点：

增加代码量，换页可能会导致操作系统的抖动，降低cache的命中率