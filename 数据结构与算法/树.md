# 树

![image-20221021140500506](%E6%A0%91.assets/image-20221021140500506.png)

度数为0的节点为树叶，

节点的度：一个节点含有的子树的个数称为该节点的度；

父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；

子节点：一个节点含有的子树的根节点称为该节点的子节点；

兄弟节点：具有相同父节点的节点互称为兄弟节点；

树的高度或深度：树中节点的最大层次，树根为0层或者第一层，子节点的层次号是父节点的层次号加1

## 二叉树

二叉树的每一个节点都有2个子树。子树有次序的（order）

![image-20221021141436092](%E6%A0%91.assets/image-20221021141436092.png)

1. n个节点，n-1条边。
2. 低i层的节点的个数最多2的i次方
3. 高度为i的树最多2^n+1-1.高度从0开始算
4. 结论4

![image-20221021142044807](%E6%A0%91.assets/image-20221021142044807.png)

用数学归纳法

![image-20221021142203434](%E6%A0%91.assets/image-20221021142203434.png)

使用结论1

结论5

![image-20221021142439293](%E6%A0%91.assets/image-20221021142439293.png)

## 特殊类型的2叉树

### 满二叉树：

节点排满，满二叉树是特殊的完全二叉树

### 完全2叉树

节点从左到右，从上到下排成的节点

### 完全二叉树性质

父节点的标号i![image-20221021143507642](%E6%A0%91.assets/image-20221021143507642.png)

子节点![image-20221021143443225](%E6%A0%91.assets/image-20221021143443225.png)

![image-20221021143855708](%E6%A0%91.assets/image-20221021143855708.png)

二叉树的存放方式

![image-20221021144959886](%E6%A0%91.assets/image-20221021144959886.png)

![image-20221021150739234](%E6%A0%91.assets/image-20221021150739234.png)

函数指针，用于执行指针的代码

![image-20221021153803281](%E6%A0%91.assets/image-20221021153803281.png)

![image-20221021153815652](%E6%A0%91.assets/image-20221021153815652.png)

递归算法遍历，用栈的方式实现

![image-20221028150153280](%E6%A0%91.assets/image-20221028150153280.png)

关键点，递归和左子树和右子树的数量![image-20221028152726820](%E6%A0%91.assets/image-20221028152726820.png)

左子女右兄弟

![image-20221029143847222](%E6%A0%91.assets/image-20221029143847222.png)

没有递归中序列遍历，

先遍历左子树，后遍历

```
算法思想：
1.栈的先进先出的性质，由于先把左子树节点都存到栈里面
2.从栈取出后，开始打印自己，然后把遍历的节点移动到右子树上面（方便下面打印右子树。）
```

![image-20221029144933875](%E6%A0%91.assets/image-20221029144933875.png)

![image-20221029145633331](%E6%A0%91.assets/image-20221029145633331.png)

[(21条消息) C++实现二叉树 前、中、后序遍历（递归与非递归）非递归实现过程最简洁版本_gy1012的博客-CSDN博客_后序遍历的非递归算法](https://blog.csdn.net/czy47/article/details/81254984)

![image-20221029150733322](%E6%A0%91.assets/image-20221029152152601.png)

左子女右兄弟可以把一个森林变成二叉树

![image-20221029152346074](%E6%A0%91.assets/image-20221029152351971.png)

![image-20221029152758435](%E6%A0%91.assets/image-20221029152758435.png)

![image-20221029154447439](%E6%A0%91.assets/image-20221029154447439.png)

![image-20221029154641519](%E6%A0%91.assets/image-20221029154641519.png)

pre是p的前一个节点

![image-20221029154746569](%E6%A0%91.assets/image-20221029154746569.png)

右儿子为空，设置pre的后继是p，左儿子为空，设置p的前驱是pre

## 中序线索二叉树的构建：

做一遍普通二叉树的中序遍历，然后给一个中序遍历

```
1.访问结束的时候用一个pre的指针保存
如果pre的右子树是null，那么pre的右子树指向p
如果p的左子树为null，那么p的左指数指向pre//pre是中序遍历的前驱节点
```

## 霍夫曼树，增长树

![](http://pic.mikumifa.cn/2022/11/02/de763fb19749a.png)

度数为1的加一个

度数为0的加上2个。

![](http://pic.mikumifa.cn/2022/11/02/6112ed5fe9341.png)

![](http://pic.mikumifa.cn/2022/11/02/e2a1f232646cf.png)

用小的二叉树作为子树，然后把子树的权重插入原来之中，然后进行迭代

![](http://pic.mikumifa.cn/2022/11/02/fd06c01d5d612.png)

内节点的权值和外结点一样的时候应该插在末尾，内节点的裙纸就是哈夫曼子树的长度。（是的路径的长度也是最短的）

霍夫曼数的作用，使用霍夫曼编码

![](http://pic.mikumifa.cn/2022/11/02/c1994f0c27cce.png)

字符最少，就是让权重乘以字符的长度最短，字符的长度可以抽象为哈夫曼树的路径的长度
