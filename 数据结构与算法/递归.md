# 递归

原因：有很多想不清楚的算法，可以用递推方式做出来。

上层逻辑层：

下层物理层：

> java，main函数写在类的里面，main函数要加public static void 
>
> public要写在所有的前面，
>
> ```java
> System.out.println(" ");//打印
> ```

java前面加public是什么意思，加static是什么意思？？？？
$$
f(0)=0;f(1)=1;f(n)=f(n-1)+f(n-2);n>=2
$$

> x效率低，但是代码简洁

#### 递归经典的汉罗塔

基本情况，A上面只有一个铁盘，

求N规模的问题，假设N-1的规模的问题可以解决，研究从N-1到N的方法。	

### 物理层

调用栈，调用栈里面放的是代数值

| 。。。      |
| ----------- |
| f函数第三轮 |
| f函数第二轮 |
| g函数       |
| f函数       |
| main,函数   |

编译器用调用栈来控制。**一定要写处理条件，防止内存爆掉，无限调用下去**

#### 排序算法

##### selection sort

```java
//选择一个最大值或者最小值，放到最后面或者//分析算法复杂度，比较操作，和数据移动次数最前面
MAX函数，selectionSort函数。然后swap
//分析算法复杂度，比较操作，和数据移动次数（swap，的数据移动次数3次）
//动态分析比较次数，n-1+n-2+....+3+2+1=
//数据比较次数是（n-1）*n/2
//先写求最大值，然后再写排序
```

##### bubble sort

```java
//每次都和前面的比，使得最大的会冒泡到最上面
//写个冒泡，然后再写冒泡排序
//数据比较次数是（n-1）*n/2
```

##### rank sort

```java
//产生排名
//打比赛的方式，和每一个都比较一次，胜利的+1
//根据排名来换顺序
//扫描一遍，把排名换到对应的位置。
13024
```

##### Sequential Search

```
public static int SequentialSearch(int[] a,int n,int target){
	for(int i=0;i<n&&a[i]!=target;i++);
	if(u==n) return -1;
	return i;
}
```



#### Best,Worst,and Average Operation Count

- 平均比较次数要求的是等概率的，前提条件是等概率的。
- 最优就是最优
- 最差就是最差的

##### insertion sort

```java
//插入排序技巧
//insert()函数
//技巧是从后往前走。
/*
	1235678
	123567 8
	12356 78
	1235 678
	123 5678
	12345678
*/
```

Asymptotie Notation(O)

假设数据规模大]
